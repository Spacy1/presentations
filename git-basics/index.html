<!DOCTYPE html>
<html lang="en">

<head>
  <title>Git</title>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="stylesheet" href="shower/themes/ribbon/styles/screen-16x10.css">
  <link rel="stylesheet" href="style.css">
</head>

<body class="shower list">

  <section class="slide intro bg-img"></section>

  <section class="slide">
    <h2>Системы контроля версий</h2>
    <p>Категория программных инструментов, которые помогают команде управлять изменениями
      исходного кода с течением времени. VCS отслеживает каждую модификацию кода
      в специальном хранилище, как в базе данных.
    </p>
  </section>

  <section class="slide">
    <h2>Преимущества систем контроля версий</h2>
    <ul>
      <li>Полная история изменений каждого файла.</li>
      <li>Ветвление и слияние.</li>
      <li>Возможность проследить изменения до их источника.</li>
      <li>Командная разработка.</li>
    </ul>
  </section>

  <section class="slide">
    <h2>Установка Git</h2>
    <ul>
      <li>
        <a href="https://sourceforge.net/projects/git-osx-installer/files/" target="_blank">Git для Mac</a>
      </li>
      <li>
        <a href="https://git-for-windows.github.io/" target="_blank">Git для Windows</a>
      </li>
      <li>Linux
        <code>$ sudo apt-get update</code>
        <code>$ sudo apt-get install git</code>
      </li>
    </ul>
    <p>После установки:</p>
    <code>$ git --version</code>
    <br>
    <code>$ git config --global user.name "имя"</code>
    <br>
    <code>$ git config --global user.email "почта"</code>
  </section>

  <section class="slide">
    <h2>Настройка репозитория</h2>
    <p>
      <strong>Репозиторий Git</strong> - это виртуальное хранилище проекта. Он позволяет
      сохранять версии кода, к любой из которых можно получить доступ когда это необходимо.</p>
    <ul>
      <li>Инициализация нового репозитория Git</li>
      <li>Клонирование существующего репозитория Git</li>
      <li>Коммит измененной версии файла</li>
      <li>Настройка репозитория Git для удаленной совместной работы</li>
      <li>Базовые команды Git</li>
    </ul>
  </section>

  <section class="slide">
    <h2>git init</h2>
    <p>Чтобы создать новое репо, используется команда
      <code>git init</code>. Это одноразовая команда, которую использют во время первоначальной
      настройки нового репо. Выполнение этой команды создаст новый подкаталог
      <code>.git</code>
      в вашем текущем рабочем каталоге. Это также создаст ветку
      <code>master</code>.</p>
  </section>

  <section class="slide">
    <h2>git clone</h2>
    <p>Если проект уже существует в центральном репозитории (удаленно),
      <code>git clone</code> используется для создания копии удаленного репозитория.
    </p>

    <code>$ git clone [URL-адрес репозитория]</code>

    <p>URL-адрес репозитория состоит из 3-х частей:</p>
    <ul>
      <li>HOSTNAME</li>
      <li>USERNAME</li>
      <li>REPONAME</li>
    </ul>
  </section>

  <section class="slide">
    <h2>git status/add/commit</h2>

    <p>
      <code>git status</code> отображает состояние рабочего каталога и промежуточной области.
      Команда
      <code>git add [flag]</code> добавляет изменения в рабочем каталоге в промежуточную
      область (staging area). Она сообщает Git, что вы хотите включить обновления
      определенного файла в следующем коммите. Однако
      <code>git add</code> не влияет на репозиторий - изменения фактически не записываются
      до тех пор, пока вы не выполните
      <code>git commit [flag][message]</code>.
    </p>

  </section>

  <section class="slide">
    <h2>Шаблон edit/stage/commit</h2>
    <p>Сначала редактируются файлы в рабочем каталоге. Когда нужно сохранить копию текущего
      состояния проекта, выполняется
      <code>git add</code> добавляя изменения в stage. После этого, делается коммит
      <code>git commit</code>, и изменения записываются в историю проекта.
    </p>
    <img src="pictures/git-tpl.svg" alt="">
  </section>

  <section class="slide">
    <h2>Staging Area</h2>
    <p>Промежуточная область (stage), думайте о ней как о буфере между рабочим каталогом
      и историей проекта.</p>
    <p>Вместо того, чтобы коммитить все изменения, внесенные с момента последнего коммита,
      stage позволяет группировать связанные изменения в снимки состояний, прежде
      чем передать их в историю проекта.</p>
    <p>Важно создавать автономные коммиты, чтобы было легко отслеживать ошибки и возвращать
      изменения с минимальным воздействием на остальную часть проекта.</p>
  </section>

  <section class="slide">
    <h2>Детально о git commit</h2>
    <p>
      <code>git commit</code> передает поэтапный снимок в историю проекта. Записанные снимки
      можно рассматривать как «безопасные» версии проекта. Git никогда не изменит
      их, если ясно не попросить об этом. Снимки
      <strong>всегда</strong> коммитятся в локальный репозиторий.</p>

    <p>Так же, как промежуточная область является буфером между рабочим каталогом и
      историей проекта, локальный репозиторий каждого разработчика представляет собой
      буфер между их локальными изменениями и центральным хранилищем.</p>
  </section>

  <section class="slide">
    <h2>Снимки (snapshots)</h2>
    <p>Git основан на снимках, в которые записывается все содержимое каждого файла в
      каждом коммите.</p>
    <img src="pictures/snapshots.png" alt="" style="display: block; margin: auto;">
  </section>

  <section class="slide">
    <h2>.gitignore</h2>
    <p>Git видит каждый файл в вашей рабочей копии как одну из трех вещей: или</p>
    <ul>
      <li>tracked - файл, который ранее был помещен в stage или commit.</li>
      <li>untracked - файл, который не был помещен в stage или commit</li>
      <li>ignored - файл, который Git'у явно сказали игнорировать.</li>
    </ul>
    <p>Игнорируемые файлы, это как правило артефакты сборки и системные файлы, которые
      нужно исключить из истории репозитория.</p>
  </section>

  <section class="slide">
    <h2>Git stash</h2>
    <p>
      <code>git stash</code> временно сохраняет изменения которые были внесены в свою рабочую
      копию, чтобы разработчик мог работать над чем-то другим, а затем вернуться
      и повторно применить их позже. Это добно если нужно быстро переключить контекст
      и работать над чем-то другим, но разработчик уже над чем-то работает и не готов
      сделать коммит.</p>
    <code>$git stash</code>
    <br>
    <code>$git stash pop</code>
  </section>

  <section class="slide">
    <h2>git log</h2>
    <p>Отображает снимки коммитов. Позволяет просматривать историю проекта.
      <code>git status</code> проверяет рабочий каталог и промежуточную область,
      <code>git log</code> работает только с зафиксированной истории.
    </p>
    <img src="pictures/log.svg" alt="" style="display: block; width: 85%">
  </section>

  <section class="slide">
    <h2>Ветвление (branching)</h2>
    <p>Ветвь представляет собой независимую линию развития проекта. Можно думать о них
      как о способе запросить новый рабочий каталог, stage и историю проекта. Новые
      коммиты фиксируются в истории текущей ветви.</p>
    <img src="pictures/branching.svg" alt="">
  </section>

  <section class="slide">
    <h2>Ветвление (branching)</h2>
    <p>Ветви это часть повседневного процесса разработки. Когда нужно добавить новую
      функцию или исправить ошибку - независимо от того, насколько она велика или
      мала, вы создаете новую ветку, чтобы инкапсулировать ваши изменения. Это гарантирует,
      что неустойчивый код никогда не будет добавлен в основную кодовую базу.</p>
  </section>

  <section class="slide">
    <h2>git branch</h2>
    <p>
      <code>git branch</code> позволяет создавать, переименовывать и удалять ветви. Она
      не позволяет переключаться между ветвями. По этой причине она тесно связана
      с командами
      <code>git checkout</code> и
      <code>git merge</code>.
    </p>
    <code>git branch</code> - выведет все ветви в репозитории.
    <br>
    <code>git branch [имя]</code> - создаст ветку с именем.
    <br>
    <code>git branch [-d|-D] [имя]</code> - удалит указаную ветку по имени.
    <br>
    <code>git branch -m [имя]</code> - переименует
    <strong>текущую</strong> ветку
  </section>

  <section class="slide">
    <h2>git checkout</h2>
    <p>Позволяет перемещаться между ветвями. Переход в ветвь обновляет файлы в рабочем
      каталоге в соответствии с версией, хранящейся в этой ветке, и говорит Git записывать
      все новые коммиты в эту ветку.</p>

    <code>git checkout [имя ветки]</code> - перейти в указанную ветвь, которая уже создана.
    Git делает ветвь текущей и обновиляет рабочий каталог.

    <br>
    <code>git checkout -b [имя-новой-ветки]</code> - удобное сокращение, флаг
    <code>-b</code> говорит создать ветвь с указаным именем, а
    <code>checkout</code> перейдет в нее после создания.
  </section>

  <section class="slide">
    <h2>git merge</h2>
    <p>Слияние - это способ совместить раздвоенную историю.
      <code>git merge</code> берет две ветви и сливает их в одну.</p>
    <p>Обратите внимание, что все команды сливают
      <strong>в текущую ветку</strong>. Текущая ветка будет обновлена, чтобы отразить слияние,
      но целевая ветвь не будет затронута.</p>
    <code>git merge [имя-ветви]</code> - cлить указанную ветку в текущую ветку.
  </section>

  <section class="slide">
    <h2>Conflicts</h2>
    <p>Если две ветви, которые вы пытаетесь объединить, изменили одну и ту же часть
      одного и того же файла, Git не сможет определить, какую версию использовать.
      Когда возникает такая ситуация, она останавливается прямо перед фиксацией слияния,
      чтобы человек разрешил конфликты вручную.</p>
  </section>

  <section class="slide">
    <h2>Разрешение конфликтов</h2>
    <p>Большая часть процесса слияния заключается в том, что для разрешения конфликтов
      слияния используется знакомый рабочий процесс edit/stage/commit. Когда вы сталкиваетесь
      с конфликтом слияния, запуск команды
      <code>git status</code> показывает, какие файлы нужно разрешить.</p>
    <p>Затем нужно исправить файлы "как надо". Когда вы будете готовы завершить слияние,
      все, что нужно сделать, это запустить
      <code>git add</code>, чтобы сообщить Git о разрешении конфликта. Затем
      <code>git commit</code> для генерации коммита слияния.
    </p>
  </section>


  <div class="progress"></div>

  <script src="shower/shower.min.js"></script>
</body>

</html>
