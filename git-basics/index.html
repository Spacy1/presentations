<!DOCTYPE html>
<html lang="en">

<head>
    <title>Git</title>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="shower/themes/ribbon/styles/screen-16x10.css">
    <link rel="stylesheet" href="style.css">
</head>

<body class="shower list">

    <section class="slide intro bg-img"></section>

    <section class="slide">
        <h2>Системы контроля версий</h2>
        <p>Категория программных инструментов, которые помогают команде управлять изменениями
            исходного кода с течением времени. VCS отслеживает каждую модификацию
            кода в специальном хранилище, как в базе данных.
        </p>
        <ul>
            <li>Полная история изменений каждого файла.</li>
            <li>Ветвление и слияние.</li>
            <li>Возможность проследить изменения до их источника.</li>
            <li>Командная разработка.</li>
        </ul>
    </section>

    <section class="slide">
        <h2>Установка Git</h2>
        <ul>
            <li>
                <a href="https://sourceforge.net/projects/git-osx-installer/files/" target="_blank">Git для Mac</a>
            </li>
            <li>
                <a href="https://git-for-windows.github.io/" target="_blank">Git для Windows</a>
            </li>
            <li>Linux
                <code>$ sudo apt-get update</code>
                <code>$ sudo apt-get install git</code>
            </li>
        </ul>
        <p>После установки:</p>
        <code>$ git --version</code>
        <br>
        <code>$ git config --global user.name "имя"</code>
        <br>
        <code>$ git config --global user.email "почта"</code>
    </section>

    <section class="slide">
        <h2>Настройка репозитория</h2>
        <p>
            <strong>Репозиторий Git</strong> - это виртуальное хранилище проекта. Он позволяет
            сохранять версии файлов, к любой из которых можно получить доступ когда
            это необходимо.</p>
    </section>

    <section class="slide">
        <h2>git init</h2>
        <p>Чтобы создать новый репозиторий, используется команда
            <code>git init</code>. Это одноразовая команда, которую выполняют во время
            первоначальной настройки нового репозитоия. Выполнение этой команды создаст
            новый подкаталог
            <code>.git</code>
            в вашем текущем рабочем каталоге. Это также создаст ветку
            <code>master</code>.</p>
    </section>

    <section class="slide">
        <h2>git clone</h2>
        <p>Если проект уже существует в удаленном репозитории,
            <code>git clone</code> используется для создания его копии.
        </p>

        <code>$ git clone [URL-адрес репозитория]</code>

        <p>URL-адрес репозитория состоит из 3-х частей:</p>
        <ul>
            <li>HOSTNAME</li>
            <li>USERNAME</li>
            <li>REPONAME</li>
        </ul>
    </section>

    <section class="slide">
        <h2>Составляющие git проекта</h2>
        <ul>
            <li>Working directory - рабочая директория, хранит файлы проекта.
            </li>
            <li>Staging area - промежуточная область, область подготовленных файлов.</li>
            <li>Local repository - сам локальный репозиторий, хранит историю коммитов.</li>
        </ul>
        <img src="pictures/parts.svg" alt="" style="display: block; width: 70%; margin: auto;">
    </section>

    <section class="slide">
        <h2>Шаблон edit/stage/commit</h2>
        <p>Сначала редактируются файлы в рабочем каталоге. Когда нужно сохранить копию
            текущего состояния проекта, изменения добавляюся в stage. После этого,
            делается коммит, и изменения записываются в историю проекта.
        </p>
        <img src="pictures/git-tpl.svg" alt="">
    </section>

    <section class="slide">
        <h2>git status/add/commit</h2>
        <p>
            <code>git status</code> отображает состояние рабочего каталога и промежуточной
            области.
        </p>
        <p>Команда
            <code>git add</code> добавляет изменения в рабочем каталоге в промежуточную
            область. Она сообщает Git, что вы хотите включить обновления определенного
            файла в следующий коммит.</p>
        <p>Однако
            <code>git add</code> не влияет на репозиторий - изменения фактически не записываются
            до тех пор, пока вы не выполните
            <code>git commit</code>.</p>
    </section>

    <section class="slide">
        <h2>Детально о git commit</h2>
        <p>
            <code>git commit</code> передает поэтапный снимок в историю проекта. Записанные
            снимки можно рассматривать как «безопасные» версии проекта. Снимки
            <strong>всегда</strong> коммитятся в локальный репозиторий.</p>

        <p>Так же, как промежуточная область является буфером между рабочим каталогом
            и историей проекта, локальный репозиторий каждого разработчика представляет
            собой буфер между их локальными изменениями и центральным хранилищем.</p>
    </section>

    <section class="slide">
        <h2>Снимки (snapshots)</h2>
        <p>Git основан на снимках, в которые записывается все содержимое каждого файла
            в каждом коммите.</p>
        <img src="pictures/snapshots.png" alt="" style="display: block; margin: auto;">
    </section>

    <section class="slide">
        <h2>.gitignore</h2>
        <p>Файл может быть в 3-х состояних: </p>
        <ul>
            <li>tracked - файл, который ранее был помещен в stage или commit.</li>
            <li>untracked - файл, который не был помещен в stage или commit</li>
            <li>ignored - файл, который Git'у явно сказали игнорировать.</li>
        </ul>
        <p>Игнорируемые файлы, это как правило артефакты сборки и системные файлы, которые
            нужно исключить из истории репозитория. Для указания списка игнорируемых
            файлов/папок используется файл
            <code>.gitignore</code>.</p>
    </section>

    <section class="slide">
        <h2>git log</h2>
        <p>Отображает историю коммитов.
            <code>git status</code> проверяет рабочий каталог и промежуточную область,
            <code>git log</code> работает только с зафиксированной историей.
        </p>
        <img src="pictures/log.svg" alt="" style="display: block; width: 85%">
    </section>

    <section class="slide">
        <h2>Ветвление (branching)</h2>
        <p>Ветвь представляет собой независимую линию развития проекта, позволяющую
            реализовать новую функциональность проекта. Новые коммиты фиксируются
            в истории текущей ветви.</p>
        <img src="pictures/branching.svg" alt="">
    </section>

    <section class="slide">
        <h2>HEAD</h2>
        <p>Указатель на текущий коммит в текущей ветви. При создании новых коммитов,
            HEAD каждый раз перемещается на самый последний коммит в текущей ветви.</p>
        <img src="pictures/head.png" alt="" style="display: block; width: 50%; margin: auto;">
    </section>

    <section class="slide">
        <h2>git branch</h2>
        <p>
            <code>git branch</code> позволяет создавать, переименовывать и удалять ветви.
            Она не позволяет переключаться между ветвями. По этой причине она тесно
            связана с командами
            <code>git checkout</code> и
            <code>git merge</code>.
        </p>
        <code>$ git branch</code> - выведет все ветви в репозитории.
        <br>
        <code>$ git branch имя</code> - создаст ветвь с указаным именем.
        <br>
        <code>$ git branch -d имя</code> - удалит указаную ветвь.
        <br>
        <code>$ git branch -m имя</code> - переименует
        <strong>текущую</strong> ветвь
    </section>

    <section class="slide">
        <h2>git checkout</h2>
        <p>Позволяет перемещаться между ветвями. Переход в ветвь обновляет файлы в рабочем
            каталоге в соответствии с версией, хранящейся в этой ветке, и говорит
            Git записывать все новые коммиты в эту ветку.</p>

        <code>$ git checkout имя-ветки</code> - перейти в указанную ветвь, которая уже
        создана. Git делает ветвь текущей и обновиляет рабочий каталог.
        <br>
        <code>$ git checkout -b имя-новой-ветки</code> - удобное сокращение, флаг
        <code>-b</code> говорит создать ветвь с указаным именем, а
        <code>checkout</code> перейдет в нее после создания.
    </section>

    <section class="slide">
        <h2>git merge</h2>
        <p>Слияние - это способ совместить раздвоенную историю.</p>
        <p>
            <code>$ git merge branch-to-merge</code> - берет две ветви и сливает их в одну.
            Сливает
            <strong>в текущую ветвь</strong>, которая будет обновлена чтобы отразить слияние,
            но целевая ветвь не будет затронута.</p>
        <p>
            <code>merge</code> сохраняет историю ветви и создает новый коммит.</p>
        <p>Для отмены слияния используется
            <code>git merge --abort</code>.</p>
    </section>

    <section class="slide">
        <h2>git rebase</h2>
        <p>
            <code>$ git rebase branch-to-rebase-to</code> - так же сливает две ветви. В
            отличии от
            <code>merge</code>, выполняется в ветви которую мы хотим слить. Целевая ветвь
            будет обновлена чтобы отразить слияние, но текущая ветвь не будет затронута.
            Не создает коммита.

        </p>
        <p>Это может нарушить историю в публичных ветвях, используйте для работы в своих
            приватных ветвях.</p>
        <a href="https://www.youtube.com/watch?v=dO9BtPDIHJ8" target="_blank">Merge vs Rebase</a>
    </section>

    <section class="slide">
        <h2>Conflicts</h2>
        <p>Если две ветви, которые вы пытаетесь объединить, изменили одну и ту же часть
            одного и того же файла, Git не сможет определить, какую версию использовать.
            Когда возникает такая ситуация, она останавливается прямо перед фиксацией
            слияния, чтобы человек разрешил конфликты вручную.</p>
    </section>

    <section class="slide">
        <h2>Разрешение конфликтов</h2>
        <p>Большая часть процесса слияния заключается в том, что для разрешения конфликтов
            слияния используется знакомый рабочий процесс edit/stage/commit. Когда
            вы сталкиваетесь с конфликтом слияния, запуск команды
            <code>git status</code> показывает, какие файлы нужно разрешить.</p>
        <p>Затем нужно исправить файлы "как надо". Когда вы будете готовы завершить
            слияние, все, что нужно сделать, это запустить
            <code>git add</code>, чтобы сообщить Git о разрешении конфликта. Затем
            <code>git commit</code> для генерации коммита слияния.
        </p>
    </section>

    <section class="slide">
        <h2>Git stash</h2>
        <p>
            <code>git stash</code> временно сохраняет изменения которые были внесены в
            свою рабочую копию, чтобы разработчик мог работать над чем-то другим,
            а затем вернуться и повторно применить их позже. Это добно если нужно
            быстро переключить контекст и работать над чем-то другим, но разработчик
            уже над чем-то работает и не готов сделать коммит.</p>
    </section>

    <section class="slide">
        <h2>Git stash</h2>

        <code>$ git stash</code> - создаст новый stash
        <br>
        <code>$ git stash list</code> - выведет все stash'ы
        <br>
        <code>$ git stash show</code> - показать последний stash
        <br>
        <code>$ git stash pop</code> - применит последний stash
        <br>
        <code>$ git stash clear</code> - очистит
        <strong>все</strong> stash'ы
    </section>

    <section class="slide">
        <h2>git pull</h2>
        <p>
            <code>$ git pull origin ветвь</code> - получит все последние изменения из удаленной
            ветки и применит их к текущей. Алгоритм применения изменений похож на
            <code>merge</code>.
        </p>
        <p>
            <code>$ git pull --rebase</code> - работает как
            <code>rebase</code>, порядок коммитов не будет сохранен. Будут вытянуты все
            изменения удаленного репозитория, применит их к проекту так, как буд
            то ваших изменений еще нету, и уже потом поверх них будут применены локальные
            изменения.
        </p>
    </section>

    <div class="progress"></div>

    <script src="shower/shower.min.js"></script>
</body>

</html>
